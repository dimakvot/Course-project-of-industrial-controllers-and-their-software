# Project Industrial controllers and their software
 Курсовий проект з предмету промислові контролери та їх програмне забезпечення


### Зміст

[Вступ](#t0)	

[1. Оформлення блок-схеми алгоритму управління](#t1)

[2. Вибір конфігурації контролера і схем підключення](#t2)

[2.1 Схема автоматизації](#t3)

[2.2 Конфігурування МПК і схеми підключення зовнішніх пристроїв](#t4)

[3. Розроблення схеми підключення датчиків, виконавчих механізмів та інших пристроїв](#t5)

[4. Складання таблиці зовнішніх змінних та наведення конфігурацій каналів](#t6)

[5. Розробка прикладного програмного забезпечення для реалізації алгоритму управління](#t7)

[6. Розроблення імітатора об'єкта](#t8)

[7. Відлагодження програми користувача](#t9)




## <a id="t0">ВСТУП</a>

Автоматизація завжди була однією з основних складових прискорення науково-технічного прогресу.

В сучасних умовах системи автоматичного керування стали невіддільною частиною практично всіх сфер матеріального виробництва. Автоматиза́ція — є одним з напрямів науково-технічного прогресу, який спрямовано на застосування саморегульованих технічних засобів, економіко-математичних методів і систем керування, що звільняють людину від участі у процесах отримання, перетворення, передавання і використання енергії, матеріалів чи інформації, істотно зменшують міру цієї участі чи трудомісткість виконуваних операцій. Разом з терміном автоматичний, використовується поняття автоматизований, що підкреслює відносно великий ступінь участі людини у процесі.

Автоматизації, було досягнуто за рахунок різних засобів, що охоплюють: механічні, гідравлічні, пневматичні, електричні, електронні пристрої та комп'ютери, як правило, у поєднанні. У складних системах, таких як: сучасні заводи, літаки та кораблі, найчастіше, використовуються усі ці змішані застосування. 



## <a id="t1">1.Оформлення блок-схеми алгоритму управління</a>

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/object.png)

Алгоритм — це набір інструкцій, які описують порядок дій виконавця, щоб досягти результату розв'язання задачі за скінченну кількість дій; система правил виконання дискретного процесу, яка досягає поставленої мети за скінченний час. Для візуалізації алгоритмів часто використовують блок-схеми.

Процес проходить наступним чином:

1. Після натискання кнопки “ПУСК” відкривається клапан 1, і ємність наповнюється молоком до рівня 70%.
2. Подається 1–ша доза ферменту в ємність:
- відкривається клапан 2, і в дозатор подається фермент, поки не спрацює датчик верхнього рівня дозатора;
- закривається клапан 2, відкривається клапан 3 (відбувається зливання ферменту до спрацювання датчика нижнього рівня дозатора);
- закривається клапан 3.
3. Включається двигун, і протягом 3 хвилин виконується перемішування.
4. Подається друга доза ферменту в ємність.
5. Включається регулятор температури і суміш витримується у апараті  (управління кл.4) на протязі 10 хвилин при температурі 40 <sup>о</sup>С (діапазон датчика температури 0–100<sup>о</sup>С). (При цьому відлік часу починається після досягнення температури у апараті 40 <sup>о</sup>С.) після чого клапан 4 закривається.
6. Відкривається клапан 5, і виконується злив молока до досягнення нижнього рівня в ємності.
7. Відкривається клапан 6, і протягом 3 хвилин виконується промивка ємності.
8. Якщо не натиснута кнопка “СТОП”, продовжити роботу, починаючи з п.1., інакше — завершити роботу програми.

Блок-схему алгоритму управління газотурбінною установкою представлено на рисунку 1.2

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/flow-chart.png)

Рис. 1.2 - Блок-схема алгоритму управління



## <a id="t2">2. Вибір конфігурації контролера і схем підключення</a>

<a id="t3">2.1. Схема автоматизації</a>

Для вибору моделі контролера і його конфігурації необхідно визначитись з переліком технічних засобів автоматизації, які будуть використовуватись для реалізації алгоритму управління. При цьому дуже важливо знати параметри сигналів від датчиків і на виконавчі механізми. На рисунку 2.1 наведена спрощена функціональна схема автоматизації на якій показані датчики і виконавчі механізми, а також типи сигналів для їх підключення до мікропроцесорного контролера (МПК).

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/simplified-scheme.png)

Рис. 2.1 - Спрощена схема автоматизації

ВД – входи дискретні; ДВ – виходи дискретні; ВА – входи аналогові; АВ – аналогові виходи; ВІ – входи імпульсні; ІВ – імпульсні виходи;

Вибір технічних засобів:

1. Для неперервного вимірювання рівня (LE) – ультразвуковий рівнемір з вихідним сигналом 4 – 20 мА. Вхідний аналоговий сигнал (01).
2. Для сигналізації рівня дозатора (LE) – ємнісний сигналізатор рівня. Вхідні два дискретних сигнала (03) та (04). 
3. Кнопка «ПУСК» (SB) – вхідний дискретний сигнал (01).
4. Кнопка «СТОП» (SB) – вхідний дискретний сигнал (02).
5. Для вимірювання температури (ТЕ) – термометр опору з вбудованим нормуючим перетворювачем і вихідним сигналом 4 – 20 мА. Вхідний аналоговий сигнал (02).
6. Клапани КЛ1, КЛ2, КЛ3 та КЛ5, КЛ6 дискретні, електромеханічні. П’ять вихідні дискретні сигнали (02, 03, 04, 05, 06).
7. Управління двигуном М за допомогою електромагнітного пускача. Вихідні сигнали дискретні (01).
8. Клапан КЛ4 пневматичний клапан з електропневматичним аналоговим перетворювачем. Управляючий сигнал 4 – 20 мА. Аналоговий вихід (01).

Таким чином для управління об’єктом необхідно сконфігурувати МПК який забезпечує підключення: 4 дискретних вхідних сигналів, 6 дискретних вихідних сигналів, 2 вхідних аналогових сигналів 4 – 20 мА і 1 аналогового вихідного сигналу 4 – 20 мА.


<a id="t4">2.2. Конфігурування МПК і схеми підключення зовнішніх пристроїв</a>

Для реалізації алгоритму управління можна вибрати модель MODICON M340 BMX P34 2000 за наступною конфігурацією:

Модулі базового комплекту: BMX CPS 2000, P34 2000.

Шасі: BME XBP 0400 на 4 слоти з вбудованим ETHERNET.

Модулі входів-виходів:

- 1 модуль змішаних дискретних сигналів DDM 16025 на 8 входів та 8 виходів.
- 1 модуль змішаних аналогових сигналів AMM 0600 на 4 аналогових входи та 2 виходи.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/conf-plc.png)

Рис. 2.2 - Конфігурація контролера

Конфігурація контролера окрім процесорного модуля та блоку живлення включає в себе модуль дискретного вводу виводу DMM16025, який розташовано на першій позиції та включає в себе 8 дискретних входів 24 VDC, позитивна логіка та 8 релейних дискретних виходів VDC/VAC, незахищені, 2 А та модуль аналогового вводу виводу AMM0600 який розташовано на другій позиції та включає в себе 4 аналогових входи ±10В, 0…10В, 0…5В, 0…20мА, 4…20 мА 14-бітні для U, 12-бітні для I, загальна точка, час опитування модуля - 5 мс та два аналогових виходи ±10В,0…20мА,4…20 мА 12-бітні для U, 11-бітні для I, загальна точка. 



## <a id="t5">3.Розроблення схеми підключення датчиків, виконавчих механізмів та інших пристроїв</a>

Для розробки загальної схеми підключення необхідно розробити схеми підключення окремих модулів МПК. У даній системі для підключення аналогових входів та виходів було використано модуль змішаних аналогових сигналів AMM 0600 схему підключення якого показано на рисунку 3.1.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/amm-0600.png)

Рис. 3.1 – Схема підключення модуля АММ 0600

Для підключення дискретних входів та виходів було використано модуль змішаних дискретних сигналів DDM 16025 схему підключення якого показано на рисунку 3.2.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/ddm-16025.png)

Рис. 3.2 – Схема підключення модуля DDM 16025

В якості процесорного модуля було використано MODICON M340 P34 2000, з блоком живлення BMX CPS 2000, до якого під'єднані модулі аналогових та дискретних сигналів. Загальну схему підключення показано на рисунку 3.3. 

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/conn-proces.png)

Рис. 3.3 – Загальна схема підлкючень до процесорного модуля



## <a id="t6">4. Складання таблиці зовнішніх змінних та наведення конфігурацій каналів.</a>

Адреси входів-виходів М340 

Вхідні канали

| Джерело сигналу | Позначення СА | Назва в ПЛК | Адреса |
| --- | --- | --- | --- |
| Кнопка «ПУСК» | SB | start | %I0.2.0 |
| Кнопка «СТОП» | SB | stop | %I0.2.1 |
| Сигналізатор рівня, аналоговий | LE | LE_all | %IW0.1.0 |
| Датчик температури| TE | TE | %IW0.1.1 |
| Сигналізатор рівня| LE | LE_min| %I0.2.2 |
| Сигналізатор рівня| LE | LE_max | %I0.2.3 |

Вихідні канали

| Джерело сигналу | Позначення СА | Назва в ПЛК | Адреса |
| --- | --- | --- | --- |
| Клапан подачі молока | Кл1 | KL1 | %Q0.2.16 |
| Клапан подачі ферменту | Кл2 | KL2 | %Q0.2.17 |
| Клапан подачі ферменту з дозатора в резервуар | Кл3 | KL3 | %Q0.2.18 |
| Клапан подачі пари | Кл4 | KL4 | %QW0.1.4 |
| Клапан зливу| Кл5 | KL5 | %Q0.2.19 |
| Клапан подачі води | Кл6 | KL5 | %Q0.2.20 |
| Мішалка | М | М1 | %Q0.2.21 |

Після складання схем підключення та конфігурування входів-виходів виконується конфігурація окремих модулів. Конфігурацію процесорного модуля показано на рисунку 4.1.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/conf-p342000.png)

Рис. 4.1 – Конфігурація модуля базового комплексу

Конфігурація дискретного модуля зображена на рисунку 4.2 

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/conf-ddm16025.png)

Рис. 4.2 – Конфігурація модуля дискретних сигналів DMM16025

Конфігурація аналогових входів та виходів модуля BMX AMM 0600 зображена на рисунку 4.3

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/conf-amm0600.png)

Рис. 4.3 – Конфігурація модуля аналогових сигналів AMM0600



## <a id="t7">5. Розробка прикладного програмного забезпечення для реалізації алгоритму управління</a>

Контролери серії MODICON M340 програмуються за допомогою програмного забезпечення UNITY PRO XL. Для полегшення орієнтації в програмі вона була розділена на чотири під-програми. Оскільки задача являє собою покроковий алгоритм для його реалізації було обрано мому функціональних блоків FBD. 

Програма користувача складається з таких під-програм:

- Programs основна програма у якій відбувається ініціалізація кроків;
- analog у даній програмі відбувається масштабування всіх аналогових сигналів;
- PI_B у даній програмі відбувається управління ПІ-регулятором;
- hmi програма передачі даних на скаду.

Лістинг під-програми Programm наведено на рисунку 5.1.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/programs.png)

Рис. 5.1 – Лістинг під-програми Programs

Розглянемо під-програму детальніше. Під-програма реалізована на кроках «StepProg», при запуску програми «StepProg» знаходиться в «0» тим самим активує функціональний блок «EQ» в якого умова спрацювання дорівнює (StepProg = 0), далі сигнал надходить на функціональний блок «AND» який об’єднує в собі два сигнали та на виході видає один сигнал, умова спрацювання даного елемента нажата кнопка «start» після чого сигнал надходить на функціональний блок «RS» що в свою чергу вмикає клапан №1 також сигнал надходить і на функціональний блок «EQ» тим самим вмикає його, умова спрацювання даного функціонального блока є тим що рівень в ємності дорівнює 70%, в такому випадку спрацює даний функціональний блок який в свою чергу вимкне клапан №1 та змінить значення кроку з 0 на 1, в такому випадку ми переходимо до наступного кроку програми.  Зображення алгоритму програми на рисунку 5.2.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/prog-pusk.png)

Рис. 5.2 – Початок програми, реалізація «ПУСКУ»

Далі ми переходимо до кроку програми №1 де виконується подача першої дози ферменту в ємність. Програма реалізована наступним чином, що сигнал з «StepProg» надходить на функціональний блок «EQ<sup><small>7</small></sup>», де порівнюється зі значенням кроку 1, після чого на функціональний блок «OR<sup><small>9</small></sup>», також на даний елемент надходить сигнал в випадку виконання 4-го кроку для повторення дії. Після функціонального блоку «OR<sup><small>9</small></sup>» сигнал подається на функціональний блок «AND<sup><small>10</small></sup>», який спрацює в випадку якщо закритий клапан №1. Після чого сигнал надходить на відкриття клапану №2 функціональний блок «RS<sup><small>20</small></sup>» також на функціональний блок «EQ<sup><small>11</small></sup>» де порівнюється з іншим сигналом функціонального блоку «EQ<sup><small>14</small></sup>» який знаходить перед ним і має умову виконання LE_max = 1, в такому випадку, функціональні блоки «EQ<sup><small>13</small></sup>» та «EQ<sup><small>14</small></sup>» спрацюють в тому випадку якщо програма перейде на крок №5 та в свою чергу переведуть крок виконання програми на №5. Після того як виконався крок програми №1 ми переходи до наступного кроку під №2 який в свою чергу спрацює якщо на вході в функціональний блок «EQ<sup></small>16</small></sup>» буде (StepProg = 2), сигнал піде через функціональний блок «OR<sup><small>18</small></sup>»  який в свою чергу перевірить умову заповнення рівня дозатору ферментом в функціональному блоку «AND<sup><small>19</small></sup>» який в свою чергу вмикає клапан №3, та включить функціональний блок «EQ<sup><small>21</small></sup>» де перевіряється умова що дозатор з ферментом пустий, після чого програма подає сигнал на функціональний блок «SR<sup><small>22</small></sup>» що в свою чергу відімкне клапан №3 та перейде на крок виконання №3 в випадку якщо умова в функціональному блоку «EQ<sup><small>25</small></sup>» виконається. Крок програми №5 працює аналогічно як і 2 крок, тільки для переходу на крок виконання програми №6 повинна працювати умова в функціональному блоку «EQ<sup><small>23</small></sup>», а саме відсутність в дозаторі фермента яка порівнюється з «true», а сам функціональний блоку буде ввімкнений при виконанні кроку програми №5. Зображення алгоритму програми на рисунку 5.3.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/prog-dozator.png)

Рис. 5.3 – Подача дози ферменту в ємність

Після того як 1-ша доза ферменту подалась в апарат ми переходимо до наступного кроку програми №3. Реалізований даний крок через функціональний блок «EQ», який порівнює сигнал з «StepProg», в випадку якщо він дорівняє 3 ми виконуємо наступні дії. Сигнал з функціонального блоку «EQ<sup><small>27</small></sup>» подається на функціональний блок «RS<sup><small>29</small></sup>» який в свою чергу вмикає двигун перемішувача, також сигнал надходить на функціональний блок «TON<sup><small>28</small></sup>» даний функціональний блок є таймером на затримку ввімкнення, затримка стоїть 10 хвилин, після чого спрацює таймер який в свою чергу відімкне двигун перемішувача та в свою чергу переведе програму на крок виконання №4, кроки виконання №4 та №5 були описані вище. Зображення алгоритму програми на рисунку 5.4.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/prog-motor.png)

Рис. 5.4 – Включення двигуна на 3 хвилини та подача другої дози ферменту в ємність

Після того як виконаються кроки програми №4 та №5 ми перейдемо на крок програми під №6 де буде виконано включення регулятора температури і суміш витримується в апараті на протязі 10 хвилин при температурі 40 С. Реалізовано це наступним чином, функціональний блок «EQ<sup><small>31</small></sup>» виконує ту саму функцію як і на початку інших кроків, після того як програма перейде на крок №6, з функціонального блоку «EQ<sup><small>31</small></sup>» піде сигнал на функціональний блок «GE<sup><small>32</small></sup>» який виконує функцію порівняння температури, після того як в апараті температура суміші дорівнює 40 С, сигнал з функціонального блоку «GE<sup><small>32</small></sup>» надходить на функціональний блок таймера затримки ввімкнення «TON<sup><small>33</small></sup>», після витримки в 10 хвилин сигнал надходить на функціональний блок «MOVE<sup><small>34</small></sup>» де StepProg отримує значення кроку програми №7, таким чином ми переходимо на крок програми №7. Зображення алгоритму програми на рисунку 5.5.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/prog-regul.png)

Рис. 5.5 – Включення регулятора температури та витримка температури в апараті 40 С протягом 10 хвилин

Регулювання температури клапаном №4 реалізовано наступним чином. В під-програмі PI_B, функціональний блок «PI_B<sup><small>3</small></sup>» який викликається з затримкою 200 мс, за режим регулювання відповідає змінна «PID_MAN» яка під’єднана до входу «MAN_AUTO» та перемикає режими з ручного на автоматичний, змінна «TE_a» яка під’єднана до входу «PV» передає плинне значення температури, на вхід «SP» під’єднана змінна «PID_SP» яка відповідає за уставку регулятора, на вхід «PARA» під’єднана змінна «Para» яка передає задані значення масштабування та складових регулятора, на вхід «OUT» під’єднана змінна масштабованого значення клапану №4 «KL4_a». Функціональний блок «SEL<sup><small>4</small></sup>» відповідає за ручну установку відкриття клапану №4, якщо змінна «PID_MAN» буде дорівнювати 0 тоді лише можна керувати клапаном в ручному режимі. Зображення алгоритму під-програми на рисунку 5.6.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/prog-pi.png)

Рис. 5.6 – Під-програма роботи ПІ-регулятора для управління клапаном

Після того як виконаються кроки програми №6 ми перейдемо на крок програми під №7 де буде виконано злив молока з ємності. Реалізовано це наступним чином, функціональний блок «EQ<sup><small>37</small></sup>» виконує ту саму функцію як і на початку інших кроків, після його працювання сигнал поступає на функціональні блоки «RS<sup><small>43</small></sup>», «EQ<sup>39</sup>» та «REAL_TO_INT<sup><small>38</small></sup>» для перетворення значення «REAL» в «INT». Функціональний блок «EQ<sup><small>37</small></sup>» після працювання включає клапан №5 та включає два функціональних блока «EQ<sup>39</sup>» та «REAL_TO_INT<sup><small>38</small></sup>», після того як ємність буде пуста спрацює функціональних блока «EQ<sup><small>39</small></sup>» який в свою чергу переведе програму на крок виконання №8. Зображення алгоритму програми на рисунку 5.7.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/prog-kl5-sliv.png)

Рис. 5.7 – Відкриття клапану №5 та злив молока з ємності 

Після того як виконаються кроки програми №7 ми перейдемо на крок програми під №8 де буде виконано промивка ємності та перевірка натиснення кнопки стоп. Реалізовано це наступним чином, функціональний блок «EQ<sup><small>41</small></sup>» виконує ту саму функцію як і на початку інших кроків, після його працювання сигнал поступає на функціональні блоки «RS<sup>44</sup>» та «TON<sup><small>42</small></sup>». Функціональний блок «RS<sup>44</sup>» вмикає клапан №6 та функціональний блок таймера затримки включення «TON<sup><small>42</small></sup>» з затримкою 3 хвилини. Після спрацювання функціональний блок таймера затримки включення «TON<sup><small>42</small></sup>» сигнал з нього піде на функціональні блоки «RS<sup><small>43</small></sup>», «RS<sup><small>44</small></sup>», «EQ<sup><small>45</small></sup>» та «EQ<sup><small>47</small></sup>», в свою чергу функціональний блок «RS<sup><small>43</small></sup>» відключить клапан №5, а функціональний блок «RS<sup><small>44</small></sup>» відключить клапан №6. Функціональні блоки «AND<sup>43</sup>» та «AND<sup>45</sup>» спрацюють в випадку здійснення умови нажата кнопка стоп чи ні, в випадку якщо кнопка стоп не нажата програма буде виконуватись через функціональний блок «AND<sup><small>43</small></sup>» яка переведе крок виконання на №0 що в свою чергу приведе до повторення програми, в випадку якщо кнопка стоп буде нажата виконається функціональний блок «AND<sup><small>45</small></sup>» який присвоює крок програми №256. Після чого буде виконуватись функціональний блок «EQ<sup><small>47</small></sup>» в випадку якщо крок програми буде №256 сигнал з даного функціонального блоку піде на інший функціональний блок «AND<sup><small>48</small></sup>» який перевіряє умову не нажатої кнопки стоп, в цьому випадку спрацює даний функціональний блок який переведе програму з кроку №256 на крок №0. Зображення алгоритму програми на рисунку 5.8.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/prog-clear.png)

Рис. 5.8 – Промивка апарату протягом 3 хвилин та повторення циклу. Реалізація кнопки стоп 

Під-програма «analog» виконує функцію маштабування аналогових сигналів. Працює вона наступним чином, функціональний блок «INT_TO_REAL» передає сигнал з датчика «LE_all» та «TE» в відповідний функціональних блок «SCALING» де перетворюється в необхідні межі вимірювання датчика, для датчика рівня «LE_all» межі виміру від 0 до 100, а датчика температури «TE» межі виміру від 0 до 100. Для передачі даних на клапан виконується такий же метод перетворення тільки навпаки з відмаштабованого значення в аналоговий сигнал для точнішого відкриття клапану. Зображення під-програми на рисунку 5.9.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/prog-analog.png)

Рис. 5.9 – Під-програма маштабування аналогових сигналів

## <a id="t8">6. Розроблення імітатора об’єкта</a>

Імітатор об’єкта призначений для перевірки правильності розробленої програми перед введенням її безпосередньо на об’єкті. Імітатор об’єкта складається з під-програми «Imit» та під-програми «riv\_doz».

Лістинг під-програми Imit наведено на рисунку 6.1.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/prog-imit.png)

Рис. 6.1 – Під-програма Imit

Розглянемо під-програму детальніше. Реалізація імітації наповнення резервуара створена наступним чином, на функціональний блок «SEL<sup>1</sup>» приходить сигнал від клапану №1 якщо сигнал клапана буде 0 тоді на виході функціонального блок «SEL<sup>1</sup>» буде подано 0, а якщо сигнал клапану №1 буде 1 то на виході вже буде 10. Після цього сигнал надходить на функціональний блок «ADD<sup><small>2</small></sup>» де додається з сигналом з датчика рівня «LE_all»,  далі надходить в функціональний блок «LIMIT<sup><small>3</small></sup>» де сигнал обмежується в рамки від 0 до 10000 на вихід з даного функціонального блоку під’єднано функціональний блок «WRITE_TO_INPUT_INT<sup><small>4</small></sup>» на виході якого вказана змінна датчика рівня «LE_all», таким чином відбувається імітація рівня в резервуарі. Зображення імітації наповнення резервуара на рисунку 6.2.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/imit-rezerv.png)

Рис. 6.2 – Імітація наповнення рівня в резервуарі

Розглянемо імітацію наповнення ферментом резервуара. Реалізація імітації наповнення рівня резервуара ферментом була створена наступним чином, на функціональний блок «SEL<sup><small>5</small></sup>» приходить сигнал від клапану №2 якщо сигнал клапана буде 0 тоді на виході функціонального блок «SEL<sup><small>5</small></sup>» буде подано 0, а якщо сигнал клапану №2 буде 1 то на виході вже буде 10. Після цього сигнал надходить на функціональний блок «ADD<sup><small>6</small></sup>» де додається з віртуальною змінною «imt_doz» яка виконує функцію відображення наповнення резервуару, далі надходить в функціональний блок «LIMIT<sup><small>7</small></sup>» де сигнал обмежується в рамки від 0 до 4000, після чого сигнал з виходу даного функціонального блоку надходить в «MOVE<sup><small>8</small></sup>» де присвоюється значення рівня віртуальній змінній «imt_doz», також на функціональні блоки «EQ». Функціональний блок «EQ<sup><small>9</small></sup>» порівняє сигнал зі значенням 0, в цьому випадку резервуар є пустий і сигнал надходить на функціональний блок «WRITE_INPUT_EBOOL<sup><small>10</small></sup>» на виході якого вказана змінна датчика рівня «LE_min». Таким чином працює і функціональний блок «EQ<sup><small>20</small></sup>» який перевіряє сигнал з значенням 4000 далі подається сигнал на таймер затримки включення «TON<sup><small>21</small></sup>» з затримкою 3 секунди для відображення на операторському екрані що набрався рівень дозатора та спрацював датчик, таким чином відбувається імітація наповнення ферментом резервуара. Зображення імітації наповнення фермента з  резервуара на рисунку 6.3.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/imit-ferm.png)

Рис. 6.3 – Імітація наповнення фермента з резервуара

Розглянемо імітацію зливу з резервуару. Реалізація імітації зливу ферменту була розроблена так само як і наповнення ферментом тільки при бінарному вибору в функціональному блоці «SEL<sup><small>14</small></sup>» замість 10 вказано -20 для віднімання даного значення від плинного значення рівня в резервуарі. Зображення імітації зливу фермента з  резервуара на рисунку 6.4.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/imit-drain.png)

Рис. 6.4 – Імітація зливу фермента з резервуара

Розглянемо імітацію температури. Реалізація імітації температури була розроблена наступним чином, на вхід функціонального блоку «INT_TO_REAL<sup><small>23</small></sup>» приходить сигнал від датчика температури, після чого сигнал надходить на функціональний блок «MUL<sup><small>24</small></sup>» в якому відбувається множення значення температури на 0.997 після чого сигнал йде на функціональний блок «ADD<sup><small>26</small></sup>» де додається зі значенням клапана №4 яке було помножено на 0.5 після чого сигнал надходить на функціональний блок «REAL_TO_INT<sup><small>27</small></sup>» де перетворюється з REAL в INT та далі надходить на функціональний блок «WRITE_TO_INPUT_INT<sup><small>28</small></sup>» який передає значення в зміну температури, таким чином відбувається імітація температури. Зображення імітації температури на рисунку 6.5.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/imit-temp.png)

Рис. 6.5 – Імітація температури

Розглянемо імітацію наповнення рівня резервуару ферментом. Реалізація була розроблена наступним чином, якщо спрацює клапан №3, а також область даних %S6 яка спрацьовує кожні 500ms, після чого до значення датчика рівня в резервуарі буде додано 15, таким чином було реалізовано імітацію наповнення рівня резервуару. Зображення імітації наповнення резервуару ферментом на рисунку 6.5.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/imit-rezerv-ferm.png)

Рис. 6.6 – Імітація наповнення резервуару ферментом

## <a id="t9">7. Відлагодження програми користувача.</a>

Відлагодження програми відбувається в три етапи:

- Перед впровадженням на об’єкт
- Доводка програми на об’єкті перед пуском
- Доводка програми на об’єкті в режимі експлоатації

Під час першого етапу розробнику ПЗ не потрібно бути на об’єкті, необхідно лише створити ПЗ для імітації об’єкту яке буде максимально наближено імітувати технологічний процес. 

У програмному середовищі UNITY PRO імітацію вхідних сигналів можна проводити за допомогою функції WRITE_TO_INPUT цим методом можна імітувати натискання кнопок та спрацювання датчиків. Для спостереженням за зміною значень змінних можна створити операторський екран або таблицю анімації приклад операторського екрану та таблиці анімації показано на рисунку 7.1 та 7.2.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/oper-screen.png)

Рис. 7.1 – Операторський екран

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/table-value.png)

Рис. 7.2 – Таблиця анімації змінних

Для більшого наближення до реального об’єкту створено програму імітації об’єкту, що описана у попередньому пункті.

Було створений операторський екран в SCADA-систему у програмному середовищі Citect SCADA таблицю змінних SCADA-системи наведено у таблиці 7.1.

Таблиця 7.1 – Таблиця змінних SCADA-системи

| Назва в SCADA | Тип змінної | Адреса в ПЛК | За що відповідає |
| --- | --- | --- | ---- |
| start_hmi | EBOOL | %M1 | Кнопка ПУСК | 
| stop_hmi | EBOOL | %M2 | Кнопка СТОП |
| TE_a_hmi | REAL | %MW6 | Відмаштабоване значення температури |
| LE_a_hmi | REAL | %MW8 | Відмаштабоване значення рівня ємності |
| LE_min_hmi | EBOOL | %M5 | Рівень дозатора мінімальний |
| LE_max_hmi | EBOOL | %M6 | Рівень дозатора максимальний |
| KL1_hmi | EBOOL | %M7 | Клапан №1 |
| KL2_hmi | EBOOL | %M8 | Клапан №2 |
| KL3_hmi | EBOOL | %M9 | Клапан №3 |
| KL4_a_hmi | REAL | %MW10 | Відмаштабоване значення клапану №4 |
| KL5_hmi | EBOOL | %M11 | Клапан №5 |
| KL6_hmi | EBOOL | %M12 | Клапан №6 |
| M1_hmi|EBOOL | %M14 | Двигун мішалки |
| Para_kp_hmi | REAL | %MW100 | Зміна коефіцієнту пропорційності регулятора |
| Para_ti_hmi | ULONG | %MW102 | Зміна часу інтегрування регулятора |
| KL4_ruh_hmi | REAL | %MW104 | Ручне управління клапаном №4 |
| PID_SP_hmi | REAL | %MW16 | Уставка регулятора |
| PID_MAN | EBOOL | %MW15 | Режим регулювання |


Візуалізація проекту розроблена за стилем sxw_stule_1. Модифіковано сторінку «Startub» яку зображено на рисунку 7.3 на якій зображений об’єкт для якого розроблялось дане ПЗ та налаштування ПІ-регулятора.

![Image alt](https://github.com/dimakvot/Course-project-of-industrial-controllers-and-their-software/blob/main/Images/scada.png)

Рис. 7.3 - Сторінка «Startub»
